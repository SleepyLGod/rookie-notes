---
description: https://changkun.de/modern-cpp/en-us/07-thread/#7-1-Basic-of-Parallelism
---

# ğŸ¤£ Parallelism and Concurrency

### Basic

`std::thread` ç”¨äºåˆ›å»ºä¸€ä¸ªæ‰§è¡Œçš„çº¿ç¨‹å®ä¾‹ï¼Œæ‰€ä»¥å®ƒæ˜¯ä¸€åˆ‡å¹¶å‘ç¼–ç¨‹çš„åŸºç¡€ï¼Œä½¿ç”¨æ—¶éœ€è¦åŒ…å« `<thread>` å¤´æ–‡ä»¶ï¼Œ å®ƒæä¾›äº†å¾ˆå¤šåŸºæœ¬çš„çº¿ç¨‹æ“ä½œï¼Œä¾‹å¦‚ `get_id()` æ¥è·å–æ‰€åˆ›å»ºçº¿ç¨‹çš„çº¿ç¨‹ IDï¼Œä½¿ç”¨ `join()` æ¥åŠ å…¥ä¸€ä¸ªçº¿ç¨‹ç­‰ç­‰ï¼Œä¾‹å¦‚ï¼š

```cpp
#include <iostream>
#include <thread>

int main() {
    std::thread t([](){
        std::cout << "hello world." << std::endl;
    });
    t.join();
    return 0;
}
```

### Mutex and Critical Section

`std::mutex` æ˜¯ C++11 ä¸­æœ€åŸºæœ¬çš„ `mutex` ç±»ï¼Œé€šè¿‡å®ä¾‹åŒ– `std::mutex` å¯ä»¥åˆ›å»ºäº’æ–¥é‡ï¼Œ è€Œé€šè¿‡å…¶æˆå‘˜å‡½æ•° `lock()` å¯ä»¥è¿›è¡Œä¸Šé”ï¼Œ`unlock()` å¯ä»¥è¿›è¡Œè§£é”ã€‚ ä½†æ˜¯åœ¨å®é™…ç¼–å†™ä»£ç çš„è¿‡ç¨‹ä¸­ï¼Œæœ€å¥½ä¸å»ç›´æ¥è°ƒç”¨æˆå‘˜å‡½æ•°ï¼Œ å› ä¸ºè°ƒç”¨æˆå‘˜å‡½æ•°å°±éœ€è¦åœ¨æ¯ä¸ªä¸´ç•ŒåŒºçš„å‡ºå£å¤„è°ƒç”¨ `unlock()`ï¼Œå½“ç„¶ï¼Œè¿˜åŒ…æ‹¬å¼‚å¸¸ã€‚&#x20;

è¿™æ—¶å€™ C++11 è¿˜ä¸ºäº’æ–¥é‡æä¾›äº†ä¸€ä¸ª RAII è¯­æ³•çš„æ¨¡æ¿ç±» `std::lock_guard`ã€‚ RAII åœ¨ä¸å¤±ä»£ç ç®€æ´æ€§çš„åŒæ—¶ï¼Œå¾ˆå¥½çš„ä¿è¯äº†ä»£ç çš„å¼‚å¸¸å®‰å…¨æ€§ã€‚

åœ¨ RAII ç”¨æ³•ä¸‹ï¼Œå¯¹äºä¸´ç•ŒåŒºçš„äº’æ–¥é‡çš„åˆ›å»ºåªéœ€è¦åœ¨ä½œç”¨åŸŸçš„å¼€å§‹éƒ¨åˆ†ï¼Œä¾‹å¦‚ï¼š

```cpp
#include <iostream>
#include <mutex>
#include <thread>

int v = 1;

void critical_section(int change_v) {
    static std::mutex mtx;
    std::lock_guard<std::mutex> lock(mtx);

    // æ‰§è¡Œç«äº‰æ“ä½œ
    v = change_v;

    // ç¦»å¼€æ­¤ä½œç”¨åŸŸå mtx ä¼šè¢«é‡Šæ”¾
}

int main() {
    std::thread t1(critical_section, 2), t2(critical_section, 3);
    t1.join();
    t2.join();

    std::cout << v << std::endl;
    return 0;
}
```

ç”±äº C++ ä¿è¯äº†æ‰€æœ‰æ ˆå¯¹è±¡åœ¨ç”Ÿå‘½å‘¨æœŸç»“æŸæ—¶ä¼šè¢«é”€æ¯ï¼Œæ‰€ä»¥è¿™æ ·çš„ä»£ç ä¹Ÿæ˜¯å¼‚å¸¸å®‰å…¨çš„ã€‚ æ— è®º `critical_section()` æ­£å¸¸è¿”å›ã€è¿˜æ˜¯åœ¨ä¸­é€”æŠ›å‡ºå¼‚å¸¸ï¼Œéƒ½ä¼šå¼•å‘å †æ ˆå›é€€ï¼Œä¹Ÿå°±è‡ªåŠ¨è°ƒç”¨äº† `unlock()`ã€‚

è€Œ **`std::unique_lock`** åˆ™æ˜¯ç›¸å¯¹äº `std::lock_guard` å‡ºç°çš„ï¼Œ`std::unique_lock` æ›´åŠ çµæ´»ï¼Œ `std::unique_lock` çš„å¯¹è±¡ä¼šä»¥ç‹¬å æ‰€æœ‰æƒï¼ˆæ²¡æœ‰å…¶ä»–çš„ `unique_lock` å¯¹è±¡åŒæ—¶æ‹¥æœ‰æŸä¸ª `mutex` å¯¹è±¡çš„æ‰€æœ‰æƒï¼‰ çš„æ–¹å¼ç®¡ç† `mutex` å¯¹è±¡ä¸Šçš„ä¸Šé”å’Œè§£é”çš„æ“ä½œã€‚æ‰€ä»¥åœ¨å¹¶å‘ç¼–ç¨‹ä¸­ï¼Œæ¨èä½¿ç”¨ `std::unique_lock`ã€‚

`std::lock_guard` ä¸èƒ½æ˜¾å¼çš„è°ƒç”¨ `lock` å’Œ `unlock`ï¼Œ è€Œ `std::unique_lock` å¯ä»¥åœ¨å£°æ˜åçš„ä»»æ„ä½ç½®è°ƒç”¨ï¼Œ å¯ä»¥ç¼©å°é”çš„ä½œç”¨èŒƒå›´ï¼Œæä¾›æ›´é«˜çš„å¹¶å‘åº¦ã€‚

å¦‚æœä½ ç”¨åˆ°äº†æ¡ä»¶å˜é‡ `std::condition_variable::wait` åˆ™å¿…é¡»ä½¿ç”¨ `std::unique_lock` ä½œä¸ºå‚æ•°ã€‚

### Futher

æœŸç‰©ï¼ˆFutureï¼‰è¡¨ç°ä¸º `std::future`ï¼Œå®ƒæä¾›äº†ä¸€ä¸ªè®¿é—®å¼‚æ­¥æ“ä½œç»“æœçš„é€”å¾„ï¼Œè¿™å¥è¯å¾ˆä¸å¥½ç†è§£ã€‚ ä¸ºäº†ç†è§£è¿™ä¸ªç‰¹æ€§ï¼Œæˆ‘ä»¬éœ€è¦å…ˆç†è§£ä¸€ä¸‹åœ¨ C++11 ä¹‹å‰çš„å¤šçº¿ç¨‹è¡Œä¸ºã€‚

è¯•æƒ³ï¼Œå¦‚æœæˆ‘ä»¬çš„ä¸»çº¿ç¨‹ A å¸Œæœ›æ–°å¼€è¾Ÿä¸€ä¸ªçº¿ç¨‹ B å»æ‰§è¡ŒæŸä¸ªæˆ‘ä»¬é¢„æœŸçš„ä»»åŠ¡ï¼Œå¹¶è¿”å›æˆ‘ä¸€ä¸ªç»“æœã€‚ è€Œè¿™æ—¶å€™ï¼Œçº¿ç¨‹ A å¯èƒ½æ­£åœ¨å¿™å…¶ä»–çš„äº‹æƒ…ï¼Œæ— æš‡é¡¾åŠ B çš„ç»“æœï¼Œ æ‰€ä»¥æˆ‘ä»¬ä¼šå¾ˆè‡ªç„¶çš„å¸Œæœ›èƒ½å¤Ÿåœ¨æŸä¸ªç‰¹å®šçš„æ—¶é—´è·å¾—çº¿ç¨‹ B çš„ç»“æœã€‚

åœ¨ C++11 çš„ `std::future` è¢«å¼•å…¥ä¹‹å‰ï¼Œé€šå¸¸çš„åšæ³•æ˜¯ï¼š åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ Aï¼Œåœ¨çº¿ç¨‹ A é‡Œå¯åŠ¨ä»»åŠ¡ Bï¼Œå½“å‡†å¤‡å®Œæ¯•åå‘é€ä¸€ä¸ªäº‹ä»¶ï¼Œå¹¶å°†ç»“æœä¿å­˜åœ¨å…¨å±€å˜é‡ä¸­ã€‚ è€Œä¸»å‡½æ•°çº¿ç¨‹ A é‡Œæ­£åœ¨åšå…¶ä»–çš„äº‹æƒ…ï¼Œå½“éœ€è¦ç»“æœçš„æ—¶å€™ï¼Œè°ƒç”¨ä¸€ä¸ªçº¿ç¨‹ç­‰å¾…å‡½æ•°æ¥è·å¾—æ‰§è¡Œçš„ç»“æœã€‚

è€Œ C++11 æä¾›çš„ `std::future` ç®€åŒ–äº†è¿™ä¸ªæµç¨‹ï¼Œå¯ä»¥ç”¨æ¥è·å–å¼‚æ­¥ä»»åŠ¡çš„ç»“æœã€‚ è‡ªç„¶åœ°ï¼Œæˆ‘ä»¬å¾ˆå®¹æ˜“èƒ½å¤Ÿæƒ³è±¡åˆ°æŠŠå®ƒä½œä¸ºä¸€ç§ç®€å•çš„çº¿ç¨‹åŒæ­¥æ‰‹æ®µï¼Œå³å±éšœï¼ˆ**barrier**ï¼‰ã€‚

ä¸ºäº†çœ‹ä¸€ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬è¿™é‡Œé¢å¤–ä½¿ç”¨ `std::packaged_task`ï¼Œå®ƒå¯ä»¥ç”¨æ¥å°è£…ä»»ä½•å¯ä»¥è°ƒç”¨çš„ç›®æ ‡ï¼Œä»è€Œç”¨äºå®ç°å¼‚æ­¥çš„è°ƒç”¨ã€‚ ä¸¾ä¾‹æ¥è¯´ï¼š

```cpp
#include <iostream>
#include <future>
#include <thread>

int main() {
    // å°†ä¸€ä¸ªè¿”å›å€¼ä¸º7çš„ lambda è¡¨è¾¾å¼å°è£…åˆ° task ä¸­
    // std::packaged_task çš„æ¨¡æ¿å‚æ•°ä¸ºè¦å°è£…å‡½æ•°çš„ç±»å‹
    std::packaged_task<int()> task([](){return 7;});
    // è·å¾— task çš„æœŸç‰©
    std::future<int> result = task.get_future(); // åœ¨ä¸€ä¸ªçº¿ç¨‹ä¸­æ‰§è¡Œ task
    std::thread(std::move(task)).detach(); // move: ç§»åŠ¨æ„é€ å‡½æ•°
    std::cout << "waiting...";
    result.wait(); // åœ¨æ­¤è®¾ç½®å±éšœï¼Œé˜»å¡åˆ°æœŸç‰©çš„å®Œæˆ
    // è¾“å‡ºæ‰§è¡Œç»“æœ
    std::cout << "done!" << std:: endl << "future result is "
              << result.get() << std::endl;
    return 0;
}
```

åœ¨å°è£…å¥½è¦è°ƒç”¨çš„ç›®æ ‡åï¼Œå¯ä»¥ä½¿ç”¨ `get_future()` æ¥è·å¾—ä¸€ä¸ª `std::future` å¯¹è±¡ï¼Œä»¥ä¾¿ä¹‹åå®æ–½çº¿ç¨‹åŒæ­¥ã€‚

### Condition Variable

æ¡ä»¶å˜é‡ `std::condition_variable` æ˜¯ä¸ºäº†è§£å†³æ­»é”è€Œç”Ÿï¼Œå½“äº’æ–¥æ“ä½œä¸å¤Ÿç”¨è€Œå¼•å…¥çš„ã€‚ æ¯”å¦‚ï¼Œçº¿ç¨‹å¯èƒ½éœ€è¦ç­‰å¾…æŸä¸ªæ¡ä»¶ä¸ºçœŸæ‰èƒ½ç»§ç»­æ‰§è¡Œï¼Œ è€Œä¸€ä¸ªå¿™ç­‰å¾…å¾ªç¯ä¸­å¯èƒ½ä¼šå¯¼è‡´æ‰€æœ‰å…¶ä»–çº¿ç¨‹éƒ½æ— æ³•è¿›å…¥ä¸´ç•ŒåŒºä½¿å¾—æ¡ä»¶ä¸ºçœŸæ—¶ï¼Œå°±ä¼šå‘ç”Ÿæ­»é”ã€‚ æ‰€ä»¥ï¼Œ`condition_variable` å®ä¾‹è¢«åˆ›å»ºå‡ºç°ä¸»è¦å°±æ˜¯ç”¨äºå”¤é†’ç­‰å¾…çº¿ç¨‹ä»è€Œé¿å…æ­»é”ã€‚ `std::condition_variable`çš„ `notify_one()` ç”¨äºå”¤é†’ä¸€ä¸ªçº¿ç¨‹ï¼› `notify_all()` åˆ™æ˜¯é€šçŸ¥æ‰€æœ‰çº¿ç¨‹ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…æ¨¡å‹çš„ä¾‹å­ï¼š

```cpp
#include <queue>
#include <chrono>
#include <mutex>
#include <thread>
#include <iostream>
#include <condition_variable>


int main() {
    std::queue<int> produced_nums;
    std::mutex mtx;
    std::condition_variable cv;
    bool notified = false;  // é€šçŸ¥ä¿¡å·

    // ç”Ÿäº§è€…
    auto producer = [&]() {
        for (int i = 0; ; i++) {
            std::this_thread::sleep_for(std::chrono::milliseconds(900));
            std::unique_lock<std::mutex> lock(mtx);
            std::cout << "producing " << i << std::endl;
            produced_nums.push(i);
            notified = true;
            cv.notify_all(); // æ­¤å¤„ä¹Ÿå¯ä»¥ä½¿ç”¨ notify_one
        }
    };
    // æ¶ˆè´¹è€…
    auto consumer = [&]() {
        while (true) {
            std::unique_lock<std::mutex> lock(mtx);
            while (!notified) {  // é¿å…è™šå‡å”¤é†’
                cv.wait(lock);
            }
            // çŸ­æš‚å–æ¶ˆé”ï¼Œä½¿å¾—ç”Ÿäº§è€…æœ‰æœºä¼šåœ¨æ¶ˆè´¹è€…æ¶ˆè´¹ç©ºå‰ç»§ç»­ç”Ÿäº§
            lock.unlock();
            // æ¶ˆè´¹è€…æ…¢äºç”Ÿäº§è€…
            std::this_thread::sleep_for(std::chrono::milliseconds(1000));
            lock.lock();
            while (!produced_nums.empty()) {
                std::cout << "consuming " << produced_nums.front() << std::endl;
                produced_nums.pop();
            }
            notified = false;
        }
    };

    // åˆ†åˆ«åœ¨ä¸åŒçš„çº¿ç¨‹ä¸­è¿è¡Œ
    std::thread p(producer);
    std::thread cs[2];
    for (int i = 0; i < 2; ++i) {
        cs[i] = std::thread(consumer);
    }
    p.join();
    for (int i = 0; i < 2; ++i) {
        cs[i].join();
    }
    return 0;
}
```

å€¼å¾—ä¸€æçš„æ˜¯ï¼Œåœ¨ç”Ÿäº§è€…ä¸­æˆ‘ä»¬è™½ç„¶å¯ä»¥ä½¿ç”¨ `notify_one()`ï¼Œä½†å®é™…ä¸Šå¹¶ä¸å»ºè®®åœ¨æ­¤å¤„ä½¿ç”¨ï¼Œ å› ä¸ºåœ¨å¤šæ¶ˆè´¹è€…çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬çš„æ¶ˆè´¹è€…å®ç°ä¸­ç®€å•æ”¾å¼ƒäº†é”çš„æŒæœ‰ï¼Œè¿™ä½¿å¾—å¯èƒ½è®©å…¶ä»–æ¶ˆè´¹è€… äº‰å¤ºæ­¤é”ï¼Œä»è€Œæ›´å¥½çš„åˆ©ç”¨å¤šä¸ªæ¶ˆè´¹è€…ä¹‹é—´çš„å¹¶å‘ã€‚è¯è™½å¦‚æ­¤ï¼Œä½†å®é™…ä¸Šå› ä¸º `std::mutex` çš„æ’ä»–æ€§ï¼Œ æˆ‘ä»¬æ ¹æœ¬æ— æ³•æœŸå¾…å¤šä¸ªæ¶ˆè´¹è€…èƒ½çœŸæ­£æ„ä¹‰ä¸Šçš„å¹¶è¡Œæ¶ˆè´¹é˜Ÿåˆ—çš„ä¸­ç”Ÿäº§çš„å†…å®¹ï¼Œæˆ‘ä»¬ä»éœ€è¦ç²’åº¦æ›´ç»†çš„æ‰‹æ®µã€‚

### åŸå­æ“ä½œä¸å†…å­˜æ¨¡å‹

ç»†å¿ƒçš„è¯»è€…å¯èƒ½ä¼šå¯¹å‰ä¸€å°èŠ‚ä¸­ç”Ÿäº§è€…æ¶ˆè´¹è€…æ¨¡å‹çš„ä¾‹å­å¯èƒ½å­˜åœ¨ç¼–è¯‘å™¨ä¼˜åŒ–å¯¼è‡´ç¨‹åºå‡ºé”™çš„æƒ…å†µäº§ç”Ÿç–‘æƒ‘ã€‚ ä¾‹å¦‚ï¼Œå¸ƒå°”å€¼ `notified` æ²¡æœ‰è¢« `volatile` ä¿®é¥°ï¼Œç¼–è¯‘å™¨å¯èƒ½å¯¹æ­¤å˜é‡å­˜åœ¨ä¼˜åŒ–ï¼Œä¾‹å¦‚å°†å…¶ä½œä¸ºä¸€ä¸ªå¯„å­˜å™¨çš„å€¼ï¼Œ ä»è€Œå¯¼è‡´æ¶ˆè´¹è€…çº¿ç¨‹æ°¸è¿œæ— æ³•è§‚å¯Ÿåˆ°æ­¤å€¼çš„å˜åŒ–ã€‚è¿™æ˜¯ä¸€ä¸ªå¥½é—®é¢˜ï¼Œä¸ºäº†è§£é‡Šæ¸…æ¥šè¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦è¿›ä¸€æ­¥è®¨è®º ä» C++ 11 èµ·å¼•å…¥çš„å†…å­˜æ¨¡å‹è¿™ä¸€æ¦‚å¿µã€‚æˆ‘ä»¬é¦–å…ˆæ¥çœ‹ä¸€ä¸ªé—®é¢˜ï¼Œä¸‹é¢è¿™æ®µä»£ç è¾“å‡ºç»“æœæ˜¯å¤šå°‘ï¼Ÿ

```cpp
#include <thread>
#include <iostream>

int main() {
    int a = 0;
    int flag = 0;

    std::thread t1([&]() {
        while (flag != 1);

        int b = a;
        std::cout << "b = " << b << std::endl;
    });

    std::thread t2([&]() {
        a = 5;
        flag = 1;
    });

    t1.join();
    t2.join();
    return 0;
}
```

ä»ç›´è§‚ä¸Šçœ‹ï¼Œ`t2` ä¸­ `a = 5;` è¿™ä¸€æ¡è¯­å¥ä¼¼ä¹æ€»åœ¨ `flag = 1;` ä¹‹å‰å¾—åˆ°æ‰§è¡Œï¼Œè€Œ `t1` ä¸­ `while (flag != 1)` ä¼¼ä¹ä¿è¯äº† `std::cout << "b = " << b << std::endl;` ä¸ä¼šå†æ ‡è®°è¢«æ”¹å˜å‰æ‰§è¡Œã€‚ä»é€»è¾‘ä¸Šçœ‹ï¼Œä¼¼ä¹ `b` çš„å€¼åº”è¯¥ç­‰äº 5ã€‚ ä½†å®é™…æƒ…å†µè¿œæ¯”æ­¤å¤æ‚å¾—å¤šï¼Œæˆ–è€…è¯´è¿™æ®µä»£ç æœ¬èº«å±äºæœªå®šä¹‰çš„è¡Œä¸ºï¼Œå› ä¸ºå¯¹äº `a` å’Œ `flag` è€Œè¨€ï¼Œä»–ä»¬åœ¨ä¸¤ä¸ªå¹¶è¡Œçš„çº¿ç¨‹ä¸­è¢«è¯»å†™ï¼Œ å‡ºç°äº†ç«äº‰ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œå³ä¾¿æˆ‘ä»¬å¿½ç•¥ç«äº‰è¯»å†™ï¼Œä»ç„¶å¯èƒ½å— CPU çš„ä¹±åºæ‰§è¡Œï¼Œç¼–è¯‘å™¨å¯¹æŒ‡ä»¤çš„é‡æ’çš„å½±å“ï¼Œ å¯¼è‡´ `a = 5` å‘ç”Ÿåœ¨ `flag = 1` ä¹‹åã€‚ä»è€Œ `b` å¯èƒ½è¾“å‡º 0ã€‚

#### åŸå­æ“ä½œ

`std::mutex` å¯ä»¥è§£å†³ä¸Šé¢å‡ºç°çš„å¹¶å‘è¯»å†™çš„é—®é¢˜ï¼Œä½†äº’æ–¥é”æ˜¯æ“ä½œç³»ç»Ÿçº§çš„åŠŸèƒ½ï¼Œ è¿™æ˜¯å› ä¸ºä¸€ä¸ªäº’æ–¥é”çš„å®ç°é€šå¸¸åŒ…å«ä¸¤æ¡åŸºæœ¬åŸç†ï¼š

1. æä¾›çº¿ç¨‹é—´è‡ªåŠ¨çš„çŠ¶æ€è½¬æ¢ï¼Œå³ã€é”ä½ã€è¿™ä¸ªçŠ¶æ€
2. ä¿éšœåœ¨äº’æ–¥é”æ“ä½œæœŸé—´ï¼Œæ‰€æ“ä½œå˜é‡çš„å†…å­˜ä¸ä¸´ç•ŒåŒºå¤–è¿›è¡Œéš”ç¦»

è¿™æ˜¯ä¸€ç»„éå¸¸å¼ºçš„åŒæ­¥æ¡ä»¶ï¼Œæ¢å¥è¯è¯´å½“æœ€ç»ˆç¼–è¯‘ä¸º CPU æŒ‡ä»¤æ—¶ä¼šè¡¨ç°ä¸ºéå¸¸å¤šçš„æŒ‡ä»¤ï¼ˆæˆ‘ä»¬ä¹‹åå†æ¥çœ‹å¦‚ä½•å®ç°ä¸€ä¸ªç®€å•çš„äº’æ–¥é”ï¼‰ã€‚ è¿™å¯¹äºä¸€ä¸ªä»…éœ€åŸå­çº§æ“ä½œï¼ˆæ²¡æœ‰ä¸­é—´æ€ï¼‰çš„å˜é‡ï¼Œä¼¼ä¹å¤ªè‹›åˆ»äº†ã€‚

å…³äºåŒæ­¥æ¡ä»¶çš„ç ”ç©¶æœ‰ç€éå¸¸ä¹…è¿œçš„å†å²ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œä¸è¿›è¡Œèµ˜è¿°ã€‚è¯»è€…åº”è¯¥æ˜ç™½ï¼Œç°ä»£ CPU ä½“ç³»ç»“æ„æä¾›äº† CPU æŒ‡ä»¤çº§çš„åŸå­æ“ä½œï¼Œ å› æ­¤åœ¨ C++11 ä¸­å¤šçº¿ç¨‹ä¸‹å…±äº«å˜é‡çš„è¯»å†™è¿™ä¸€é—®é¢˜ä¸Šï¼Œè¿˜å¼•å…¥äº† `std::atomic` æ¨¡æ¿ï¼Œä½¿å¾—æˆ‘ä»¬å®ä¾‹åŒ–ä¸€ä¸ªåŸå­ç±»å‹ï¼Œå°†ä¸€ä¸ª åŸå­ç±»å‹è¯»å†™æ“ä½œä»ä¸€ç»„æŒ‡ä»¤ï¼Œæœ€å°åŒ–åˆ°å•ä¸ª CPU æŒ‡ä»¤ã€‚ä¾‹å¦‚ï¼š

```cpp
std::atomic<int> counter;
```

å¹¶ä¸ºæ•´æ•°æˆ–æµ®ç‚¹æ•°çš„åŸå­ç±»å‹æä¾›äº†åŸºæœ¬çš„æ•°å€¼æˆå‘˜å‡½æ•°ï¼Œä¸¾ä¾‹æ¥è¯´ï¼Œ åŒ…æ‹¬ `fetch_add`, `fetch_sub` ç­‰ï¼ŒåŒæ—¶é€šè¿‡é‡è½½æ–¹ä¾¿çš„æä¾›äº†å¯¹åº”çš„ `+`ï¼Œ`-` ç‰ˆæœ¬ã€‚ æ¯”å¦‚ä¸‹é¢çš„ä¾‹å­ï¼š

```cpp
#include <atomic>
#include <thread>
#include <iostream>

std::atomic<int> count = {0};

int main() {
    std::thread t1([](){
        count.fetch_add(1);
    });
    std::thread t2([](){
        count++;        // ç­‰ä»·äº fetch_add
        count += 1;     // ç­‰ä»·äº fetch_add
    });
    t1.join();
    t2.join();
    std::cout << count << std::endl;
    return 0;
}
```

å½“ç„¶ï¼Œå¹¶éæ‰€æœ‰çš„ç±»å‹éƒ½èƒ½æä¾›åŸå­æ“ä½œï¼Œè¿™æ˜¯å› ä¸ºåŸå­æ“ä½œçš„å¯è¡Œæ€§å–å†³äºå…·ä½“çš„ CPU æ¶æ„ï¼Œä»¥åŠæ‰€å®ä¾‹åŒ–çš„ç±»å‹ç»“æ„æ˜¯å¦èƒ½å¤Ÿæ»¡è¶³è¯¥ CPU æ¶æ„å¯¹å†…å­˜å¯¹é½ æ¡ä»¶çš„è¦æ±‚ï¼Œå› è€Œæˆ‘ä»¬æ€»æ˜¯å¯ä»¥é€šè¿‡ `std::atomic<T>::is_lock_free` æ¥æ£€æŸ¥è¯¥åŸå­ç±»å‹æ˜¯å¦éœ€æ”¯æŒåŸå­æ“ä½œï¼Œä¾‹å¦‚ï¼š

```cpp
#include <atomic>
#include <iostream>

struct A {
    float x;
    int y;
    long long z;
};

int main() {
    std::atomic<A> a;
    std::cout << std::boolalpha << a.is_lock_free() << std::endl;
    return 0;
}
```

#### ä¸€è‡´æ€§æ¨¡å‹

å¹¶è¡Œæ‰§è¡Œçš„å¤šä¸ªçº¿ç¨‹ï¼Œä»æŸç§å®è§‚å±‚é¢ä¸Šè®¨è®ºï¼Œå¯ä»¥ç²—ç•¥çš„è§†ä¸ºä¸€ç§åˆ†å¸ƒå¼ç³»ç»Ÿã€‚ åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ï¼Œä»»ä½•é€šä¿¡ä¹ƒè‡³æœ¬åœ°æ“ä½œéƒ½éœ€è¦æ¶ˆè€—ä¸€å®šæ—¶é—´ï¼Œç”šè‡³å‡ºç°ä¸å¯é çš„é€šä¿¡ã€‚

å¦‚æœæˆ‘ä»¬å¼ºè¡Œå°†ä¸€ä¸ªå˜é‡ `v` åœ¨å¤šä¸ªçº¿ç¨‹ä¹‹é—´çš„æ“ä½œè®¾ä¸ºåŸå­æ“ä½œï¼Œå³ä»»ä½•ä¸€ä¸ªçº¿ç¨‹åœ¨æ“ä½œå®Œ `v` åï¼Œ å…¶ä»–çº¿ç¨‹å‡èƒ½**åŒæ­¥**æ„ŸçŸ¥åˆ° `v` çš„å˜åŒ–ï¼Œåˆ™å¯¹äºå˜é‡ `v` è€Œè¨€ï¼Œè¡¨ç°ä¸ºé¡ºåºæ‰§è¡Œçš„ç¨‹åºï¼Œå®ƒå¹¶æ²¡æœ‰ç”±äºå¼•å…¥å¤šçº¿ç¨‹ è€Œå¾—åˆ°ä»»ä½•æ•ˆç‡ä¸Šçš„æ”¶ç›Šã€‚å¯¹æ­¤æœ‰ä»€ä¹ˆåŠæ³•èƒ½å¤Ÿé€‚å½“çš„åŠ é€Ÿå‘¢ï¼Ÿç­”æ¡ˆä¾¿æ˜¯å‰Šå¼±åŸå­æ“ä½œçš„åœ¨è¿›ç¨‹é—´çš„åŒæ­¥æ¡ä»¶ã€‚

ä»åŸç†ä¸Šçœ‹ï¼Œæ¯ä¸ªçº¿ç¨‹å¯ä»¥å¯¹åº”ä¸ºä¸€ä¸ªé›†ç¾¤èŠ‚ç‚¹ï¼Œè€Œçº¿ç¨‹é—´çš„é€šä¿¡ä¹Ÿå‡ ä¹ç­‰ä»·äºé›†ç¾¤èŠ‚ç‚¹é—´çš„é€šä¿¡ã€‚ å‰Šå¼±è¿›ç¨‹é—´çš„åŒæ­¥æ¡ä»¶ï¼Œé€šå¸¸æˆ‘ä»¬ä¼šè€ƒè™‘å››ç§ä¸åŒçš„ä¸€è‡´æ€§æ¨¡å‹ï¼š

<mark style="background-color:green;">**çº¿æ€§ä¸€è‡´æ€§**</mark>ï¼šåˆç§°å¼ºä¸€è‡´æ€§æˆ–åŸå­ä¸€è‡´æ€§ã€‚å®ƒè¦æ±‚ä»»ä½•ä¸€æ¬¡è¯»æ“ä½œéƒ½èƒ½è¯»åˆ°æŸä¸ªæ•°æ®çš„æœ€è¿‘ä¸€æ¬¡å†™çš„æ•°æ®ï¼Œå¹¶ä¸”æ‰€æœ‰çº¿ç¨‹çš„æ“ä½œé¡ºåºä¸å…¨å±€æ—¶é’Ÿä¸‹çš„é¡ºåºæ˜¯ä¸€è‡´çš„ã€‚

```
        x.store(1)      x.load()
T1 ---------+----------------+------>


T2 -------------------+------------->
                x.store(2)
```

åœ¨è¿™ç§æƒ…å†µä¸‹çº¿ç¨‹ `T1`, `T2` å¯¹ `x` çš„ä¸¤æ¬¡å†™æ“ä½œæ˜¯åŸå­çš„ï¼Œä¸” `x.store(1)` æ˜¯ä¸¥æ ¼çš„å‘ç”Ÿåœ¨ `x.store(2)` ä¹‹å‰ï¼Œ`x.store(2)` ä¸¥æ ¼çš„å‘ç”Ÿåœ¨ `x.load()` ä¹‹å‰ã€‚ å€¼å¾—ä¸€æçš„æ˜¯ï¼Œçº¿æ€§ä¸€è‡´æ€§å¯¹å…¨å±€æ—¶é’Ÿçš„è¦æ±‚æ˜¯éš¾ä»¥å®ç°çš„ï¼Œè¿™ä¹Ÿæ˜¯äººä»¬ä¸æ–­ç ”ç©¶æ¯”è¿™ä¸ªä¸€è‡´æ€§æ›´å¼±æ¡ä»¶ä¸‹å…¶ä»–ä¸€è‡´æ€§çš„ç®—æ³•çš„åŸå› ã€‚

<mark style="background-color:green;">**é¡ºåºä¸€è‡´æ€§**</mark>ï¼šåŒæ ·è¦æ±‚**ä»»ä½•ä¸€æ¬¡è¯»æ“ä½œ**éƒ½èƒ½è¯»åˆ°æ•°æ®æœ€è¿‘ä¸€æ¬¡å†™å…¥çš„æ•°æ®ï¼Œä½†æœªè¦æ±‚ä¸å…¨å±€æ—¶é’Ÿçš„é¡ºåºä¸€è‡´ã€‚

```
        x.store(1)  x.store(3)   x.load()
T1 ---------+-----------+----------+----->


T2 ---------------+---------------------->
              x.store(2)

æˆ–è€…

        x.store(1)  x.store(3)   x.load()
T1 ---------+-----------+----------+----->


T2 ------+------------------------------->
      x.store(2)
```

åœ¨é¡ºåºä¸€è‡´æ€§çš„è¦æ±‚ä¸‹ï¼Œ`x.load()` å¿…é¡»è¯»åˆ°æœ€è¿‘ä¸€æ¬¡å†™å…¥çš„æ•°æ®ï¼Œå› æ­¤ `x.store(2)` ä¸ `x.store(1)` å¹¶æ— ä»»ä½•å…ˆåä¿éšœï¼Œå³ åªè¦ `T2` çš„ `x.store(2)` å‘ç”Ÿåœ¨ `x.store(3)` ä¹‹å‰å³å¯ã€‚

<mark style="background-color:green;">**å› æœä¸€è‡´æ€§**</mark>ï¼šå®ƒçš„è¦æ±‚è¿›ä¸€æ­¥é™ä½ï¼Œåªéœ€è¦æœ‰å› æœå…³ç³»çš„æ“ä½œé¡ºåºå¾—åˆ°ä¿éšœï¼Œè€Œéå› æœå…³ç³»çš„æ“ä½œé¡ºåºåˆ™ä¸åšè¦æ±‚ã€‚

```
      a = 1      b = 2
T1 ----+-----------+---------------------------->


T2 ------+--------------------+--------+-------->
      x.store(3)         c = a + b    y.load()

æˆ–è€…

      a = 1      b = 2
T1 ----+-----------+---------------------------->


T2 ------+--------------------+--------+-------->
      x.store(3)          y.load()   c = a + b

äº¦æˆ–è€…

     b = 2       a = 1
T1 ----+-----------+---------------------------->


T2 ------+--------------------+--------+-------->
      y.load()            c = a + b  x.store(3)

```

ä¸Šé¢ç»™å‡ºçš„ä¸‰ç§ä¾‹å­éƒ½æ˜¯å±äºå› æœä¸€è‡´çš„ï¼Œå› ä¸ºæ•´ä¸ªè¿‡ç¨‹ä¸­ï¼Œåªæœ‰ `c` å¯¹ `a` å’Œ `b` äº§ç”Ÿä¾èµ–ï¼Œè€Œ `x` å’Œ `y` åœ¨æ­¤ä¾‹å­ä¸­è¡¨ç°ä¸ºæ²¡æœ‰å…³ç³»ï¼ˆä½†å®é™…æƒ…å†µä¸­æˆ‘ä»¬éœ€è¦æ›´è¯¦ç»†çš„ä¿¡æ¯æ‰èƒ½ç¡®å®š `x` ä¸ `y` ç¡®å®æ— å…³ï¼‰

<mark style="background-color:green;">**æœ€ç»ˆä¸€è‡´æ€§**</mark>ï¼šæ˜¯**æœ€å¼±**çš„ä¸€è‡´æ€§è¦æ±‚ï¼Œå®ƒåªä¿éšœæŸä¸ªæ“ä½œåœ¨æœªæ¥çš„æŸä¸ªæ—¶é—´èŠ‚ç‚¹ä¸Šä¼šè¢«è§‚å¯Ÿåˆ°ï¼Œä½†å¹¶æœªè¦æ±‚è¢«è§‚å¯Ÿåˆ°çš„æ—¶é—´ã€‚å› æ­¤æˆ‘ä»¬ç”šè‡³å¯ä»¥å¯¹æ­¤æ¡ä»¶ç¨ä½œåŠ å¼ºï¼Œä¾‹å¦‚è§„å®šæŸä¸ªæ“ä½œè¢«è§‚å¯Ÿåˆ°çš„æ—¶é—´æ€»æ˜¯æœ‰ç•Œçš„ã€‚å½“ç„¶è¿™å·²ç»ä¸åœ¨æˆ‘ä»¬çš„è®¨è®ºèŒƒå›´ä¹‹å†…äº†ã€‚

```
    x.store(3)  x.store(4)
T1 ----+-----------+-------------------------------------------->


T2 ---------+------------+--------------------+--------+-------->
         x.read      x.read()           x.read()   x.read()
```

åœ¨ä¸Šé¢çš„æƒ…å†µä¸­ï¼Œå¦‚æœæˆ‘ä»¬å‡è®¾ x çš„åˆå§‹å€¼ä¸º 0ï¼Œåˆ™ `T2` ä¸­å››æ¬¡ `x.read()` ç»“æœå¯èƒ½ä½†ä¸é™äºä»¥ä¸‹æƒ…å†µï¼š

| <pre><code>3 4 4 4 // x çš„å†™æ“ä½œè¢«å¾ˆå¿«è§‚å¯Ÿåˆ°
0 3 3 4 // x çš„å†™æ“ä½œè¢«è§‚å¯Ÿåˆ°çš„æ—¶é—´å­˜åœ¨ä¸€å®šå»¶è¿Ÿ
0 0 0 4 // æœ€åä¸€æ¬¡è¯»æ“ä½œè¯»åˆ°äº† x çš„æœ€ç»ˆå€¼ï¼Œä½†æ­¤å‰çš„å˜åŒ–å¹¶æœªè§‚å¯Ÿåˆ°
0 0 0 0 // åœ¨å½“å‰æ—¶é—´æ®µå†… x çš„å†™æ“ä½œå‡æœªè¢«è§‚å¯Ÿåˆ°ï¼Œ        
        // ä½†æœªæ¥æŸä¸ªæ—¶é—´ç‚¹ä¸Šä¸€å®šèƒ½è§‚å¯Ÿåˆ° x ä¸º 4 çš„æƒ…å†µ</code></pre> |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |

#### å†…å­˜é¡ºåº

ä¸ºäº†è¿½æ±‚æè‡´çš„æ€§èƒ½ï¼Œå®ç°å„ç§å¼ºåº¦è¦æ±‚çš„ä¸€è‡´æ€§ï¼ŒC++11 ä¸ºåŸå­æ“ä½œå®šä¹‰äº†å…­ç§ä¸åŒçš„**å†…å­˜é¡ºåº** `std::memory_order` çš„é€‰é¡¹ï¼Œè¡¨è¾¾äº†å››ç§å¤šçº¿ç¨‹é—´çš„åŒæ­¥æ¨¡å‹ï¼š

<mark style="background-color:green;">**å®½æ¾æ¨¡å‹**</mark>ï¼šåœ¨æ­¤æ¨¡å‹ä¸‹ï¼Œå•ä¸ªçº¿ç¨‹å†…çš„åŸå­æ“ä½œéƒ½æ˜¯é¡ºåºæ‰§è¡Œçš„ï¼Œä¸å…è®¸æŒ‡ä»¤é‡æ’ï¼Œä½†**ä¸åŒçº¿ç¨‹**é—´åŸå­æ“ä½œçš„é¡ºåºæ˜¯ä»»æ„çš„ã€‚ç±»å‹é€šè¿‡ `std::memory_order_relaxed` æŒ‡å®šã€‚æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªä¾‹å­ï¼š

```cpp
std::atomic<int> counter = {0};
std::vector<std::thread> vt;
for (int i = 0; i < 100; ++i) {
    vt.emplace_back([&](){
        counter.fetch_add(1, std::memory_order_relaxed);
    });
}

for (auto& t : vt) {
    t.join();
}
std::cout << "current counter:" << counter << std::endl;
```

<mark style="background-color:green;">**é‡Šæ”¾/æ¶ˆè´¹æ¨¡å‹**</mark>ï¼šåœ¨æ­¤æ¨¡å‹ä¸­ï¼Œæˆ‘ä»¬å¼€å§‹é™åˆ¶è¿›ç¨‹é—´çš„æ“ä½œé¡ºåºï¼Œå¦‚æœæŸä¸ªçº¿ç¨‹éœ€è¦ä¿®æ”¹æŸä¸ªå€¼ï¼Œä½†å¦ä¸€ä¸ªçº¿ç¨‹ä¼šå¯¹è¯¥å€¼çš„æŸæ¬¡æ“ä½œäº§ç”Ÿä¾èµ–ï¼Œå³åè€…ä¾èµ–å‰è€…ã€‚å…·ä½“è€Œè¨€ï¼Œçº¿ç¨‹ A å®Œæˆäº†ä¸‰æ¬¡å¯¹ `x` çš„å†™æ“ä½œï¼Œçº¿ç¨‹ `B` ä»…ä¾èµ–å…¶ä¸­ç¬¬ä¸‰æ¬¡ `x` çš„å†™æ“ä½œï¼Œä¸ `x` çš„å‰ä¸¤æ¬¡å†™è¡Œä¸ºæ— å…³ï¼Œåˆ™å½“ `A` ä¸»åŠ¨ `x.release()` æ—¶å€™ï¼ˆå³ä½¿ç”¨ `std::memory_order_release`ï¼‰ï¼Œé€‰é¡¹ `std::memory_order_consume` èƒ½å¤Ÿç¡®ä¿ `B` åœ¨è°ƒç”¨ `x.load()` æ—¶å€™è§‚å¯Ÿåˆ° `A` ä¸­ç¬¬ä¸‰æ¬¡å¯¹ `x` çš„å†™æ“ä½œã€‚æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªä¾‹å­ï¼š

```cpp
// åˆå§‹åŒ–ä¸º nullptr é˜²æ­¢ consumer çº¿ç¨‹ä»é‡æŒ‡é’ˆè¿›è¡Œè¯»å–
std::atomic<int*> ptr(nullptr);
int v;
std::thread producer([&]() {
    int* p = new int(42);
    v = 1024;
    ptr.store(p, std::memory_order_release);
});
std::thread consumer([&]() {
    int* p;
    while(!(p = ptr.load(std::memory_order_consume)));

    std::cout << "p: " << *p << std::endl;
    std::cout << "v: " << v << std::endl;
});
producer.join();
consumer.join();
```

<mark style="background-color:green;">**é‡Šæ”¾/è·å–æ¨¡å‹**</mark>ï¼šåœ¨æ­¤æ¨¡å‹ä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥è¿›ä¸€æ­¥åŠ ç´§å¯¹ä¸åŒçº¿ç¨‹é—´åŸå­æ“ä½œçš„é¡ºåºçš„é™åˆ¶ï¼Œåœ¨é‡Šæ”¾ `std::memory_order_release` å’Œè·å– `std::memory_order_acquire` ä¹‹é—´è§„å®šæ—¶åºï¼Œå³å‘ç”Ÿåœ¨é‡Šæ”¾ï¼ˆreleaseï¼‰æ“ä½œä¹‹å‰çš„**æ‰€æœ‰**å†™æ“ä½œï¼Œå¯¹å…¶ä»–çº¿ç¨‹çš„ä»»ä½•è·å–ï¼ˆacquireï¼‰æ“ä½œéƒ½æ˜¯å¯è§çš„ï¼Œäº¦å³å‘ç”Ÿé¡ºåºï¼ˆhappens-beforeï¼‰ã€‚

å¯ä»¥çœ‹åˆ°ï¼Œ`std::memory_order_release` ç¡®ä¿äº†å®ƒä¹‹å‰çš„å†™æ“ä½œä¸ä¼šå‘ç”Ÿåœ¨é‡Šæ”¾æ“ä½œä¹‹åï¼Œæ˜¯ä¸€ä¸ªå‘åçš„å±éšœï¼ˆbackwardï¼‰ï¼Œè€Œ `std::memory_order_acquire` ç¡®ä¿äº†å®ƒä¹‹å‰çš„å†™è¡Œä¸ºä¸ä¼šå‘ç”Ÿåœ¨è¯¥è·å–æ“ä½œä¹‹åï¼Œæ˜¯ä¸€ä¸ªå‘å‰çš„å±éšœï¼ˆforwardï¼‰ã€‚å¯¹äºé€‰é¡¹ `std::memory_order_acq_rel` è€Œè¨€ï¼Œåˆ™ç»“åˆäº†è¿™ä¸¤è€…çš„ç‰¹ç‚¹ï¼Œå”¯ä¸€ç¡®å®šäº†ä¸€ä¸ªå†…å­˜å±éšœï¼Œä½¿å¾—å½“å‰çº¿ç¨‹å¯¹å†…å­˜çš„è¯»å†™ä¸ä¼šè¢«é‡æ’å¹¶è¶Šè¿‡æ­¤æ“ä½œçš„å‰åï¼š

æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªä¾‹å­ï¼š

```cpp
std::vector<int> v;
std::atomic<int> flag = {0};
std::thread release([&]() {
    v.push_back(42);
    flag.store(1, std::memory_order_release);
});
std::thread acqrel([&]() {
    int expected = 1; // must before compare_exchange_strong
    while(!flag.compare_exchange_strong(expected, 2, std::memory_order_acq_rel))
        expected = 1; // must after compare_exchange_strong
    // flag has changed to 2
});
std::thread acquire([&]() {
    while(flag.load(std::memory_order_acquire) < 2);

    std::cout << v.at(0) << std::endl; // must be 42
});
release.join();
acqrel.join();
acquire.join();
```

åœ¨æ­¤ä¾‹ä¸­æˆ‘ä»¬ä½¿ç”¨äº† `compare_exchange_strong` æ¯”è¾ƒäº¤æ¢åŸè¯­ï¼ˆCompare-and-swap primitiveï¼‰ï¼Œå®ƒæœ‰ä¸€ä¸ªæ›´å¼±çš„ç‰ˆæœ¬ï¼Œå³ `compare_exchange_weak`ï¼Œå®ƒå…è®¸å³ä¾¿äº¤æ¢æˆåŠŸï¼Œä¹Ÿä»ç„¶è¿”å› `false` å¤±è´¥ã€‚å…¶åŸå› æ˜¯å› ä¸ºåœ¨æŸäº›å¹³å°ä¸Šè™šå‡æ•…éšœå¯¼è‡´çš„ï¼Œå…·ä½“è€Œè¨€ï¼Œå½“ CPU è¿›è¡Œä¸Šä¸‹æ–‡åˆ‡æ¢æ—¶ï¼Œå¦ä¸€çº¿ç¨‹åŠ è½½åŒä¸€åœ°å€äº§ç”Ÿçš„ä¸ä¸€è‡´ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œ`compare_exchange_strong` çš„æ€§èƒ½å¯èƒ½ç¨å·®äº `compare_exchange_weak`ï¼Œä½†å¤§éƒ¨åˆ†æƒ…å†µä¸‹ï¼Œé‰´äºå…¶ä½¿ç”¨çš„å¤æ‚åº¦è€Œè¨€ï¼Œ`compare_exchange_weak` åº”è¯¥è¢«æœ‰é™è€ƒè™‘ã€‚

<mark style="background-color:green;">**é¡ºåºä¸€è‡´æ¨¡å‹**</mark>ï¼šåœ¨æ­¤æ¨¡å‹ä¸‹ï¼ŒåŸå­æ“ä½œæ»¡è¶³é¡ºåºä¸€è‡´æ€§ï¼Œè¿›è€Œå¯èƒ½å¯¹æ€§èƒ½äº§ç”ŸæŸè€—ã€‚å¯æ˜¾å¼çš„é€šè¿‡ `std::memory_order_seq_cst` è¿›è¡ŒæŒ‡å®šã€‚æœ€åæ¥çœ‹ä¸€ä¸ªä¾‹å­ï¼š

```cpp
std::atomic<int> counter = {0};
std::vector<std::thread> vt;
for (int i = 0; i < 100; ++i) {
    vt.emplace_back([&](){
        counter.fetch_add(1, std::memory_order_seq_cst);
    });
}

for (auto& t : vt) {
    t.join();
}
std::cout << "current counter:" << counter << std::endl;
```

è¿™ä¸ªä¾‹å­ä¸ç¬¬ä¸€ä¸ª**å®½æ¾æ¨¡å‹**çš„ä¾‹å­æœ¬è´¨ä¸Šæ²¡æœ‰åŒºåˆ«ï¼Œä»…ä»…åªæ˜¯å°†åŸå­æ“ä½œçš„å†…å­˜é¡ºåºä¿®æ”¹ä¸ºäº† `memory_order_seq_cst`ï¼Œæœ‰å…´è¶£çš„è¯»è€…å¯ä»¥è‡ªè¡Œç¼–å†™ç¨‹åºæµ‹é‡è¿™ä¸¤ç§ä¸åŒå†…å­˜é¡ºåºå¯¼è‡´çš„æ€§èƒ½å·®å¼‚ã€‚
